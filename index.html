<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chess Board Scanner with OpenCV.js</title>
  <style>
    /* Basic styling for a visually appealing layout */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      flex-direction: column;
    }
    .container {
      max-width: 800px;
      width: 90%;
      text-align: center;
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    h1 {
      margin-bottom: 20px;
    }
    video {
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      margin: 10px 5px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #0056b3;
    }
    #pgnDisplay {
      background-color: #e9ecef;
      padding: 15px;
      margin-top: 20px;
      border-radius: 5px;
      text-align: left;
      font-family: monospace;
      overflow-x: auto;
    }
  </style>
  <!-- Include OpenCV.js from a CDN -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <div class="container">
    <h1>Chess Board Scanner</h1>
    <video id="video" autoplay playsinline></video>
    <!-- Off-screen canvas for frame processing -->
    <canvas id="canvas" style="display: none;"></canvas>
    <div>
      <button id="startScan">Start Scanning</button>
      <button id="stopScan">Stop Scanning</button>
      <button id="savePGN">Save PGN</button>
    </div>
    <div id="pgnDisplay">
      <h2>Recorded PGN Moves</h2>
      <pre id="pgnText"></pre>
    </div>
  </div>

  <script>
    // Get page elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const startButton = document.getElementById('startScan');
    const stopButton = document.getElementById('stopScan');
    const savePGNButton = document.getElementById('savePGN');
    const pgnText = document.getElementById('pgnText');

    let scanning = false;
    let scanInterval;
    let pgnMoves = [];
    let prevBoardState = null; // To compare consecutive board states

    // Request camera access using the rear camera if available.
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => {
        video.srcObject = stream;
      })
      .catch(err => {
        console.error("Error accessing camera: ", err);
      });

    // Helper function: convert board row & column to algebraic notation.
    function squareNotation(row, col) {
      let file = String.fromCharCode('a'.charCodeAt(0) + col);
      let rank = 8 - row;
      return file + rank;
    }

    // The core function that captures a frame, detects the chessboard,
    // segments it, and compares the board state to detect a move.
    function detectChessMove() {
      // Ensure the canvas matches video dimensions
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const context = canvas.getContext('2d');
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Read the frame into an OpenCV Mat
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      let blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
      let edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);

      // Find contours in the edge-detected image
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      // Look for the largest 4-point contour which is likely the board
      let boardContour = null;
      let maxArea = 0;
      for (let i = 0; i < contours.size(); i++) {
        let contour = contours.get(i);
        let approx = new cv.Mat();
        cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);
        if (approx.rows === 4) { // A quadrilateral
          let area = cv.contourArea(approx);
          if (area > maxArea) {
            maxArea = area;
            if (boardContour !== null) boardContour.delete();
            boardContour = approx; // keep this contour
          } else {
            approx.delete();
          }
        } else {
          approx.delete();
        }
        contour.delete();
      }

      // If no board contour is found, clean up and return
      if (boardContour === null) {
        src.delete(); gray.delete(); blurred.delete(); edges.delete();
        hierarchy.delete(); contours.delete();
        return "";
      }

      // Extract and order the corner points
      let pts = [];
      for (let i = 0; i < 4; i++) {
        let point = boardContour.intPtr(i);
        pts.push({ x: point[0], y: point[1] });
      }
      // Sort by y coordinate to separate top and bottom points
      pts.sort((a, b) => a.y - b.y);
      let topPts = pts.slice(0, 2).sort((a, b) => a.x - b.x);
      let bottomPts = pts.slice(2, 4).sort((a, b) => a.x - b.x);
      // Order: top-left, top-right, bottom-right, bottom-left
      let orderedPts = [topPts[0], topPts[1], bottomPts[1], bottomPts[0]];

      // Prepare source and destination points for perspective transform.
      let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
        orderedPts[0].x, orderedPts[0].y,
        orderedPts[1].x, orderedPts[1].y,
        orderedPts[2].x, orderedPts[2].y,
        orderedPts[3].x, orderedPts[3].y
      ]);
      let boardSize = 400; // Define the desired square board size
      let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        boardSize, 0,
        boardSize, boardSize,
        0, boardSize
      ]);
      let M = cv.getPerspectiveTransform(srcTri, dstTri);
      let topDown = new cv.Mat();
      cv.warpPerspective(src, topDown, M, new cv.Size(boardSize, boardSize));

      // Segment the transformed board into 64 squares.
      let squareSize = topDown.cols / 8;
      let currentBoardState = [];
      for (let row = 0; row < 8; row++) {
        let rowState = [];
        for (let col = 0; col < 8; col++) {
          let x = col * squareSize;
          let y = row * squareSize;
          let square = topDown.roi(new cv.Rect(x, y, squareSize, squareSize));
          // For demonstration: calculate the mean intensity.
          // In practice, you would run piece detection/classification here.
          let meanScalar = cv.mean(square);
          let piecePresent = meanScalar[0] < 100; // simplistic threshold for demonstration
          rowState.push(piecePresent ? 1 : 0);
          square.delete();
        }
        currentBoardState.push(rowState);
      }

      // Compare current board state with the previous state to detect changes.
      let detectedMove = "";
      if (prevBoardState !== null) {
        let diff = [];
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (prevBoardState[i][j] !== currentBoardState[i][j]) {
              diff.push({ row: i, col: j });
            }
          }
        }
        // A simple example: if exactly two squares have changed,
        // assume one square lost a piece (source) and one gained (destination).
        if (diff.length === 2) {
          let source = diff[0];
          let dest = diff[1];
          detectedMove = squareNotation(source.row, source.col) + squareNotation(dest.row, dest.col);
        }
      }
      // Update previous board state for the next frame comparison.
      prevBoardState = currentBoardState;

      // Clean up allocated resources.
      src.delete(); gray.delete(); blurred.delete(); edges.delete();
      srcTri.delete(); dstTri.delete(); M.delete();
      topDown.delete();
      boardContour.delete(); hierarchy.delete(); contours.delete();

      // Return the detected move (or an empty string if none detected).
      return detectedMove || "no move detected";
    }

    // Start scanning: process frames periodically to detect moves.
    function startScanning() {
      if (scanning) return;
      scanning = true;
      scanInterval = setInterval(() => {
        const move = detectChessMove();
        if (move && move !== "no move detected") {
          pgnMoves.push(move);
          pgnText.textContent = pgnMoves.join(' ');
        }
      }, 3000); // Adjust interval as needed
    }

    // Stop scanning
    function stopScanning() {
      scanning = false;
      clearInterval(scanInterval);
    }

    // Save PGN moves as a text file.
    function savePGN() {
      const pgnData = pgnMoves.join(' ');
      const blob = new Blob([pgnData], { type: "text/plain;charset=utf-8" });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "chess_game.pgn";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Event listeners for buttons.
    startButton.addEventListener('click', startScanning);
    stopButton.addEventListener('click', stopScanning);
    savePGNButton.addEventListener('click', savePGN);
  </script>
</body>
</html>
